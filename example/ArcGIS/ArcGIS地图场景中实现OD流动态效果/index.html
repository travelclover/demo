<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>ArcGIS地图场景中实现OD流动态效果</title>
    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
    </style>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.24/esri/css/main.css"
    />
    <script src="https://js.arcgis.com/4.24/"></script>

    <!-- 片段着色器 -->
    <script id="shader-fs" type="x-shader/x-fragment">
      precision mediump float;
      void main(void) {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);
      }
    </script>

    <!-- 顶点着色器 -->
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uModelViewMatrix;
      void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
      }
    </script>

    <script type="module">
      import * as THREE from '../../../libs/threejs/three.module.r119.js';

      require([
        'esri/core/Accessor',
        'esri/Map',
        'esri/Basemap',
        'esri/views/SceneView',
        'esri/layers/TileLayer',
        'esri/geometry/Polyline',
        'esri/views/3d/externalRenderers',
        'esri/geometry/support/webMercatorUtils',
        'https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.3.2/gl-matrix-min.js',
      ], function (
        Accessor,
        Map,
        Basemap,
        SceneView,
        TileLayer,
        Polyline,
        externalRenderers,
        webMercatorUtils,
        glMatrix
      ) {
        const basemap = new Basemap({
          baseLayers: [
            new TileLayer({
              url: 'http://map.geoq.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer',
              title: 'Basemap',
            }),
          ],
        });
        const map = new Map({
          basemap: basemap,
        });

        const view = new SceneView({
          container: 'viewDiv',
          map: map,
          camera: {
            position: [
              106.81728807741148, 17.973344421207273, 3726356.6413883436,
            ],
            tilt: 21.902354973840445,
          },
        });
        window.view = view;
        view.on('click', function (e) {
          console.log(e);
        });

        const MyExternalRenderer = Accessor.createSubclass({
          view: null,
          points: [],
          localOriginRender: null, // 渲染坐标系中的原点坐标
          program: null, // webgl程序
          programAttributeVertexPosition: null, // 顶点变量位置索引
          programUniformProjectionMatrix: null, // 投影矩阵
          programUniformModelViewMatrix: null, // 模型视图矩阵
          vboPositions: null, // 顶点数据缓冲区
          iboPositions: null, // 顶点索引数据缓冲区
          inputToRenders: null, // 变换矩阵数组

          tempMatrix4: new Float32Array(16), // 临时4阶矩阵变量

          constructor: function (view) {
            this.view = view;
            const z = 1;
            const spatialReference = view.spatialReference;
            this.points = [
              {
                x: 11584436.586885221,
                y: 3588413.52726299,
                z,
                spatialReference,
              },
              {
                x: 11584439.366543537,
                y: 3588259.371329044,
                z,
                spatialReference,
              },
              {
                x: 11584681.532858152,
                y: 3588263.8720208947,
                z,
                spatialReference,
              },
              {
                x: 11584679.209025547,
                y: 3588420.3518584534,
                z,
                spatialReference,
              },
            ];
          },

          setup: function (context) {
            const gl = context.gl;
            this.initShaders(context); // 初始化着色器
            this.initData(context); // 初始化数据

            // cleanup
            context.resetWebGLState();
          },

          render: function (context) {
            const gl = context.gl;

            gl.disable(gl.DEPTH_TEST); // 关闭深度比较
            gl.enable(gl.CULL_FACE); // 多边形剔除
            // gl.disable(gl.BLEND); // 关闭计算的片段颜色值的混合
            gl.enable(gl.BLEND); // 开启计算的片段颜色值的混合
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // 渲染管线α融合功能单元配置

            gl.useProgram(this.program);
            this.setCommonUniforms(context);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vboPositions);
            gl.enableVertexAttribArray(this.programAttributeVertexPosition);
            gl.vertexAttribPointer(
              this.programAttributeVertexPosition,
              3,
              gl.FLOAT,
              false,
              0,
              0
            );

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iboPositions);

            glMatrix.mat4.identity(this.tempMatrix4); // 将this.tempMatrix4设置为单位矩阵
            // 通过将视图矩阵平移到局部原点来应用局部原点，这将把视图原点(0,0,0)放到局部原点
            glMatrix.mat4.translate(
              this.tempMatrix4, // 用于接收结果的矩阵
              this.tempMatrix4, // 要平移的矩阵
              this.localOriginRender // 要平移的向量
            );
            // 矩阵相乘
            glMatrix.mat4.multiply(
              this.tempMatrix4,
              context.camera.viewMatrix,
              this.tempMatrix4
            );
            // 设置统一变量数据
            gl.uniformMatrix4fv(
              this.programUniformModelViewMatrix,
              false,
              this.tempMatrix4
            );

            gl.drawElements(
              gl.TRIANGLES, // 指定要渲染的类型
              6, // 指定要渲染的绑定元素数组缓冲区的元素数
              gl.UNSIGNED_SHORT, // 指定元素数组缓冲区中的值的类型
              0 // 指定元素数组缓冲区中的字节偏移量。必须是给定类型大小的有效倍数
            );

            // 一直绘制
            externalRenderers.requestRender(view);

            // cleanup
            context.resetWebGLState();
          },

          // 初始化着色器
          initShaders: function (context) {
            const gl = context.gl;
            const fragmentShader = this.getShader(gl, 'shader-fs'); // 获取片元着色器
            const vertexShader = this.getShader(gl, 'shader-vs'); // 获取顶点着色器
            this.program = this.linkProgram(gl, fragmentShader, vertexShader); // 链接给定的WebGLProgram，从而完成为程序的片元和顶点着色器准备 GPU 代码的过程
            gl.useProgram(this.program); // 将定义好的WebGLProgram 对象添加到当前的渲染状态中

            this.programAttributeVertexPosition = gl.getAttribLocation(
              this.program,
              'aVertexPosition'
            );
            gl.enableVertexAttribArray(this.programAttributeVertexPosition); // 通过传入索引来激活顶点属性

            // 通过统一变量的名称获取变量的位置
            // 投影矩阵
            this.programUniformProjectionMatrix = gl.getUniformLocation(
              this.program,
              'uProjectionMatrix'
            );
            // 模型视图矩阵
            this.programUniformModelViewMatrix = gl.getUniformLocation(
              this.program,
              'uModelViewMatrix'
            );
          },

          // 初始化数据
          initData: function (context) {
            const gl = context.gl;

            // 设置一个局部原点
            const localOriginSR = this.view.spatialReference; // 局部原点空间参考
            const localOrigin = [11584557.664716301, 3588340.6236806326, 0]; // 局部原点坐标
            // 在渲染坐标中以32位精度计算局部原点
            this.localOriginRender = externalRenderers.toRenderCoordinates(
              this.view, // sceneView
              localOrigin, // 坐标
              0, // 开始读取坐标的索引
              localOriginSR, // 空间参考
              new Float32Array(3), // 对将写入结果的数组的引用
              0, // 将开始写入坐标的索引
              1 // 要变换的顶点数
            );

            // 转换后渲染坐标系中的各顶点坐标
            const vertexToRender = new Float64Array(this.points.length * 3);
            this.inputToRenders = new Array(this.points.length); // 变换矩阵数组

            for (let i = 0; i < this.points.length; i++) {
              const point = this.points[i];
              // 从输入坐标到渲染坐标的转换
              const inputSR = point.spatialReference; // 输入图形的空间参考
              const p = [point.x, point.y, point.z];
              // 生成变换矩阵,其中下标为12,13,14的元素分别为变换后点的[x, y, z]坐标值
              const inputToRender =
                externalRenderers.renderCoordinateTransformAt(
                  view,
                  p,
                  inputSR,
                  new Float64Array(16)
                );
              this.inputToRenders[i] = inputToRender;

              vertexToRender[i * 3] = inputToRender[12];
              vertexToRender[i * 3 + 1] = inputToRender[13];
              vertexToRender[i * 3 + 2] = inputToRender[14];
            }

            // 减去局部原点坐标
            glMatrix.vec3.forEach(
              vertexToRender,
              0, // 每个 vec3 开始之间的元素数。如果 0 假设紧密包装
              0, // 在数组开头要跳过的元素数
              0, // 要迭代的 vec3 数量。如果 0 遍历整个数组
              glMatrix.vec3.subtract, // 从向量 a 中减去向量 b
              this.localOriginRender // 传递给 glMatrix.vec3.subtract方法的附加参数，渲染坐标系中的局部原点坐标
            );

            this.vboPositions = this.createVertexBuffer(gl, vertexToRender);
            this.iboPositions = this.createIndexBuffer(
              gl,
              new Uint16Array([0, 1, 2, 1, 2, 3])
            );
          },

          setCommonUniforms: function (context) {
            const gl = context.gl;
            const camera = context.camera;

            gl.uniformMatrix4fv(
              this.programUniformProjectionMatrix, // 要设置的统一变量的位置，通过 gl.getUniformLocation()方法获取位置
              false, // 是否转置矩阵，只能是false
              camera.projectionMatrix // 要设置的矩阵值
            );
          },

          // 从<script>中加载着色器
          getShader: function (gl, id) {
            const shaderScript = document.getElementById(id);
            if (!shaderScript) return null;

            let str = '';
            let k = shaderScript.firstChild;
            while (k) {
              if (k.nodeType === 3) {
                // 如果是文本节点
                str += k.textContent;
              }
              k = k.nextSibling;
            }

            let shader;
            if (shaderScript.type === 'x-shader/x-fragment') {
              // 片元着色器
              shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type === 'x-shader/x-vertex') {
              // 顶点着色器
              shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
              return null;
            }

            gl.shaderSource(shader, str); // 设置着色器源代码
            gl.compileShader(shader); // 将着色器编译为二进制数据
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
              alert(gl.getShaderInfoLog(shader));
              return null;
            }

            return shader;
          },

          linkProgram: function (gl, fragmentShader, vertexShader) {
            // 创建并初始化一个 WebGLProgram 对象
            const shaderProgram = gl.createProgram();

            // 将片段或顶点着色器 附加到 WebGLProgram
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            // 链接给定的 WebGLProgram
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
              return null;
            }

            return shaderProgram;
          },

          // 创建顶点缓冲区
          createVertexBuffer(gl, data) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const float32Data = new Float32Array(data);
            gl.bufferData(gl.ARRAY_BUFFER, float32Data, gl.STATIC_DRAW);
            return buffer;
          },

          // 创建索引缓冲区
          createIndexBuffer(gl, data) {
            const buffer = gl.createBuffer(); // 创建并初始化一个缓冲区
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); // 将缓冲区绑定到用于元素索引的缓冲区
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); // 初始化并创建缓冲区对象的数据存储
            return buffer;
          },
        });

        const myExternalRenderer = new MyExternalRenderer(view);

        // 注册renderer
        externalRenderers.add(view, myExternalRenderer);
      });
    </script>
  </head>
  <body>
    <div id="viewDiv"></div>
  </body>
</html>
